// 'ty = Type.t
// 'term = Term.t
// 
// Type.t = { 
//  view: (unit, var, t) Imandrax_api.Ty_view.view;
//  generation: generation;
// }
//
// Imandrax_api.Ty_view.view (* A general type expression for ImandraX *)
// type ('lbl, 'var, +'t) view =
//   | Var of 'var
//   | Arrow of 'lbl * 't * 't
//   | Tuple of 't list
//   | Constr of Uid.t * 't list
// Here 'lbl = unit, 'var = Imandrax_api.Uid.t, 't = Type.t
//
// Term.t 
// type t = {
//   view: (t, Type.t) view;
//   ty: Type.t;
//   generation: (generation[@ocaml_only]);
//   sub_anchor: Imandrax_api.Sub_anchor.t option;
// }
// 
// Term.view
// type ('t, 'ty) view =
//   ADT of Const, If, Apply, Var, Sym, Construct, Destruct, Is_a, Tuple, Field, 
//   Tuple_field, Record, Case

{ tys = [];
  consts =
    // ('ty Applied_symbol.t_poly * 'term) list;
    [
      // 'ty Applied_symbol.t_poly * 'term
      (
        // 'ty Applied_symbol.t_poly
        (
            // 'ty Typed_symbol.t_poly
            // id: Imandrax_api.Uid.t
            // ty: 'ty Type_schema.t_poly
            // where 'ty Type_schema.t_poly = {
            //  params: Imandrax_api.Uid.t list;
            //  ty: 'ty;
            // }
            x/252218 : { 
                view = (Constr (int, [])); 
                generation = 1 
            }
        ),
        // 'term = Term.t
        { 
            // (Term.t, Type.t) Term.view
            view = (Const 0); 
            // Type.t
            ty = { view = (Constr (int, [])); generation = 1 };
            generation = 0; 
            sub_anchor = None 
        }
      )
    ];
  funs = []; representable = true; completed = true; ty_subst = [] }

// extract the first element of the consts list
// extract the applied symbol's uid
//   ignore its view? (as it will be the same as Term.t's view)
// 
// the second element of the consts list is the term
//   view is of type (Term.t, Type.t) Term.view 
//   ty is of type Type.t