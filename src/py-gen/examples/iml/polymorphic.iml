type 'a box = Box of 'a

type ('a, 'b) pair = Pair of 'a * 'b

type 'a tree =
  | Leaf
  | Node of 'a * 'a tree * 'a tree

type ('k, 'v) map_entry = {
  key: 'k;
  value: 'v;
  next: ('k, 'v) map_entry option;
}

type 'a result =
  | Ok of 'a
  | Error of LString.t

type ('a, 'e) either =
  | Left of 'a
  | Right of 'e

type 'a list_wrapper = 'a list

let model_box (b: int box) =
  match b with
  | Box x -> x <> 0

let model_pair (p: (LString.t, int) pair) =
  match p with
  | Pair (s, i) -> LString.length s > 0 && i > 0

let model_tree (t: int tree) =
  match t with
  | Leaf -> false
  | Node (_, _, _) -> true

let model_map_entry (e: (LString.t, int) map_entry) =
  LString.length e.key > 0

let model_result (r: int result) =
  match r with
  | Ok x -> x > 0
  | Error msg -> LString.length msg > 0

let model_either (e: (int, LString.t) either) = true

let model_list_wrapper (l: int list_wrapper) = List.length l > 0
