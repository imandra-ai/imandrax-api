type int_list =
  | Nil
  | Cons of int * int_list

type 'a binary_tree =
  | Empty
  | Node of 'a * 'a binary_tree * 'a binary_tree

type json =
  | Null
  | Bool of bool
  | Number of real
  | String of LString.t
  | Array of json list
  | Object of (LString.t * json) list

type expr =
  | Lit of int
  | Var of LString.t
  | Add of expr * expr
  | Mul of expr * expr
  | Let of LString.t * expr * expr

type node = {
  id: int;
  children: node list;
}

type tree_node = {
  value: int;
  left: tree_node option;
  right: tree_node option;
}

type file_system =
  | File of { name: LString.t; size: int }
  | Directory of { name: LString.t; contents: file_system list }

type a_type = B of b_type
and b_type = A of a_type | Done

type even = Zero | Succ of odd
and odd = Succ of even

let model_int_list (l: int_list) =
  match l with
  | Nil -> false
  | Cons (_, _) -> true

let model_binary_tree (t: int binary_tree) =
  match t with
  | Empty -> false
  | Node (_, _, _) -> true

let model_json (j: json) =
  match j with
  | Null -> false
  | Bool _ -> true
  | Number _ -> true
  | String s -> LString.length s > 0
  | Array lst -> List.length lst > 0
  | Object lst -> List.length lst > 0

let model_expr (e: expr) = true

let model_node (n: node) = n.id > 0

let model_tree_node (n: tree_node) = n.value <> 0

let model_file_system (fs: file_system) =
  match fs with
  | File {name; size} -> LString.length name > 0 && size > 0
  | Directory {name; contents} -> LString.length name > 0

let model_a_type (a: a_type) = true

let model_even (e: even) = true
