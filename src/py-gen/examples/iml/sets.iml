(* Set: IML-specific type for collections of unique elements *)
(* Set.t is implemented as (('a, bool) Map.t) *)

(* Basic sets *)
type int_set = int Set.t
type string_set = LString.t Set.t
type point_set = (int * int) Set.t

(* Creating sets *)
let make_empty_set () : int_set =
  Set.empty

let make_full_set () : int_set =
  Set.full

let make_set_from_list () : int_set =
  Set.of_list [1; 2; 3; 4; 5]

let make_string_set () : string_set =
  Set.of_list [{l|apple|l}; {l|banana|l}; {l|cherry|l}]

(* Set operations *)
let add_element (s : int_set) : int_set =
  Set.add 42 s

let remove_element (s : int_set) : int_set =
  Set.remove 42 s

let check_membership (s : int_set) : bool =
  Set.mem 42 s

let is_empty_check (s : int_set) : bool =
  Set.is_empty s

(* Set algebra operations *)
let union_example () : int_set =
  let s1 = Set.of_list [1; 2; 3] in
  let s2 = Set.of_list [3; 4; 5] in
  Set.union s1 s2

let intersection_example () : int_set =
  let s1 = Set.of_list [1; 2; 3; 4] in
  let s2 = Set.of_list [3; 4; 5; 6] in
  Set.inter s1 s2

let difference_example () : int_set =
  let s1 = Set.of_list [1; 2; 3; 4; 5] in
  let s2 = Set.of_list [3; 4] in
  Set.diff s1 s2

let complement_example (s : int_set) : int_set =
  Set.complement s

(* Using infix operators *)
let union_infix () : int_set =
  let s1 = Set.of_list [1; 2] in
  let s2 = Set.of_list [3; 4] in
  Set.(++) s1 s2

let diff_infix () : int_set =
  let s1 = Set.of_list [1; 2; 3; 4] in
  let s2 = Set.of_list [3; 4] in
  Set.(--) s1 s2

(* Subset checking *)
let subset_check () : bool =
  let s1 = Set.of_list [1; 2] in
  let s2 = Set.of_list [1; 2; 3; 4] in
  Set.subset s1 s2

(* Complex example: set of user IDs *)
let active_users () : int_set =
  Set.of_list [1; 2; 3; 5; 8; 13]

let admin_users () : int_set =
  Set.of_list [2; 5]

let non_admin_active_users () : int_set =
  Set.diff (active_users ()) (admin_users ())
