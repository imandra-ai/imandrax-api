(* Tuples: products of multiple types *)

(* Basic tuples *)
type int_string_pair = int * LString.t
type triple = int * LString.t * bool
type nested_tuple = (int * int) * (LString.t * LString.t)

(* Tuples with various types *)
type point_tuple = int * int
type coordinate_3d = real * real * real
type mixed_tuple = bool * int * LString.t * real

(* Tuples in type constructors *)
type tuple_option = (int * LString.t) option
type tuple_list = (int * int) list
type nested_tuple_list = ((int * int) * LString.t) list

(* Complex tuples *)
type tuple_with_option = int * (LString.t option) * bool
type tuple_with_list = int * (int list) * LString.t
type large_tuple = int * LString.t * bool * real * int list * (int * int)

let model_int_string_pair (p: int_string_pair) =
  let (i, s) = p in
  i > 0 && LString.length s > 0

let model_triple (t: triple) =
  let (i, s, b) = t in
  i >= 0 && LString.length s > 0

let model_nested_tuple (t: nested_tuple) =
  let ((x1, y1), (s1, s2)) = t in
  x1 >= 0 && y1 >= 0 && LString.length s1 > 0 && LString.length s2 > 0

let model_point_tuple (p: point_tuple) =
  let (x, y) = p in
  x >= 0 && y >= 0

let model_coordinate_3d (c: coordinate_3d) =
  let (x, y, z) = c in
  Real.(x >= of_int 0 && y >= of_int 0 && z >= of_int 0)

let model_mixed_tuple (t: mixed_tuple) =
  let (b, i, s, r) = t in
  i > 0 && LString.length s > 0

let model_tuple_option (o: tuple_option) = o <> None

let model_tuple_list (l: tuple_list) = List.length l > 0

let model_nested_tuple_list (l: nested_tuple_list) = List.length l > 0

let model_tuple_with_option (t: tuple_with_option) =
  let (i, o, b) = t in
  i > 0

let model_tuple_with_list (t: tuple_with_list) =
  let (i, lst, s) = t in
  i > 0 && List.length lst > 0 && LString.length s > 0

let model_large_tuple (t: large_tuple) =
  let (i, s, b, r, lst, (x, y)) = t in
  i > 0 && LString.length s > 0 && List.length lst > 0
