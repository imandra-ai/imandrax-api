// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.1
// source: simple_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Art } from "./artmsg";
import { Error } from "./error";
import { Session } from "./session";
import { Task } from "./task";
import { Empty, StringMsg } from "./utils";

export const protobufPackage = "imandrax.simple";

export enum LiftBool {
  Default = 0,
  NestedEqualities = 1,
  Equalities = 2,
  All = 3,
  UNRECOGNIZED = -1,
}

export function liftBoolFromJSON(object: any): LiftBool {
  switch (object) {
    case 0:
    case "Default":
      return LiftBool.Default;
    case 1:
    case "NestedEqualities":
      return LiftBool.NestedEqualities;
    case 2:
    case "Equalities":
      return LiftBool.Equalities;
    case 3:
    case "All":
      return LiftBool.All;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LiftBool.UNRECOGNIZED;
  }
}

export function liftBoolToJSON(object: LiftBool): string {
  switch (object) {
    case LiftBool.Default:
      return "Default";
    case LiftBool.NestedEqualities:
      return "NestedEqualities";
    case LiftBool.Equalities:
      return "Equalities";
    case LiftBool.All:
      return "All";
    case LiftBool.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ModelType {
  Counter_example = 0,
  Instance = 1,
  UNRECOGNIZED = -1,
}

export function modelTypeFromJSON(object: any): ModelType {
  switch (object) {
    case 0:
    case "Counter_example":
      return ModelType.Counter_example;
    case 1:
    case "Instance":
      return ModelType.Instance;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelType.UNRECOGNIZED;
  }
}

export function modelTypeToJSON(object: ModelType): string {
  switch (object) {
    case ModelType.Counter_example:
      return "Counter_example";
    case ModelType.Instance:
      return "Instance";
    case ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SessionCreateReq {
  /** the API types version (mandatory) */
  apiVersion: string;
}

export interface DecomposeReq {
  session:
    | Session
    | undefined;
  /** name of function to decompose */
  name: string;
  /** name of side condition function */
  assuming?: string | undefined;
  basis: string[];
  ruleSpecs: string[];
  prune: boolean;
  ctxSimp?: boolean | undefined;
  liftBool?: LiftBool | undefined;
  str?: boolean | undefined;
}

/** Result of a decomposition */
export interface DecomposeRes {
  artifact?: Art | undefined;
  err?: Empty | undefined;
  errors: Error[];
  /** the ID of the task */
  task: Task | undefined;
}

export interface EvalSrcReq {
  session:
    | Session
    | undefined;
  /** source code to evaluate */
  src: string;
}

export interface EvalRes {
  success: boolean;
  /** "normal" messages */
  messages: string[];
  /** akin to stderr */
  errors: Error[];
  /** all tasks started during eval */
  tasks: Task[];
}

export interface VerifySrcReq {
  session:
    | Session
    | undefined;
  /** source code */
  src: string;
  hints?: string | undefined;
}

export interface VerifyNameReq {
  session:
    | Session
    | undefined;
  /** name of the predicate to verify */
  name: string;
  hints?: string | undefined;
}

export interface InstanceSrcReq {
  session:
    | Session
    | undefined;
  /** source code */
  src: string;
  hints?: string | undefined;
}

export interface InstanceNameReq {
  session:
    | Session
    | undefined;
  /** name of the predicate to verify */
  name: string;
  hints?: string | undefined;
}

export interface Proved {
  proofPp?: string | undefined;
}

export interface Unsat {
  proofPp?: string | undefined;
}

export interface Model {
  mType: ModelType;
  /** iml source code for the model */
  src: string;
  /** the model as an artifact */
  artifact?: Art | undefined;
}

export interface Refuted {
  model?: Model | undefined;
}

export interface Sat {
  model?: Model | undefined;
}

export interface VerifyRes {
  unknown?: StringMsg | undefined;
  err?: Empty | undefined;
  proved?: Proved | undefined;
  refuted?: Refuted | undefined;
  errors: Error[];
  /** the ID of the task */
  task: Task | undefined;
}

export interface InstanceRes {
  unknown?: StringMsg | undefined;
  err?: Empty | undefined;
  unsat?: Unsat | undefined;
  sat?: Sat | undefined;
  errors: Error[];
  /** the ID of the task */
  task: Task | undefined;
}

export interface TypecheckReq {
  session:
    | Session
    | undefined;
  /** source code to evaluate */
  src: string;
}

export interface TypecheckRes {
  success: boolean;
  /** JSON dictionary of inferred types. */
  types: string;
  /** akin to stderr */
  errors: Error[];
}

function createBaseSessionCreateReq(): SessionCreateReq {
  return { apiVersion: "" };
}

export const SessionCreateReq: MessageFns<SessionCreateReq> = {
  encode(message: SessionCreateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionCreateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionCreateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionCreateReq {
    return { apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "" };
  },

  toJSON(message: SessionCreateReq): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionCreateReq>, I>>(base?: I): SessionCreateReq {
    return SessionCreateReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionCreateReq>, I>>(object: I): SessionCreateReq {
    const message = createBaseSessionCreateReq();
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseDecomposeReq(): DecomposeReq {
  return {
    session: undefined,
    name: "",
    assuming: undefined,
    basis: [],
    ruleSpecs: [],
    prune: false,
    ctxSimp: undefined,
    liftBool: undefined,
    str: undefined,
  };
}

export const DecomposeReq: MessageFns<DecomposeReq> = {
  encode(message: DecomposeReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.assuming !== undefined) {
      writer.uint32(26).string(message.assuming);
    }
    for (const v of message.basis) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.ruleSpecs) {
      writer.uint32(42).string(v!);
    }
    if (message.prune !== false) {
      writer.uint32(48).bool(message.prune);
    }
    if (message.ctxSimp !== undefined) {
      writer.uint32(56).bool(message.ctxSimp);
    }
    if (message.liftBool !== undefined) {
      writer.uint32(64).int32(message.liftBool);
    }
    if (message.str !== undefined) {
      writer.uint32(72).bool(message.str);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecomposeReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecomposeReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assuming = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.basis.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ruleSpecs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prune = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ctxSimp = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.liftBool = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.str = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecomposeReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assuming: isSet(object.assuming) ? globalThis.String(object.assuming) : undefined,
      basis: globalThis.Array.isArray(object?.basis) ? object.basis.map((e: any) => globalThis.String(e)) : [],
      ruleSpecs: globalThis.Array.isArray(object?.ruleSpecs)
        ? object.ruleSpecs.map((e: any) => globalThis.String(e))
        : [],
      prune: isSet(object.prune) ? globalThis.Boolean(object.prune) : false,
      ctxSimp: isSet(object.ctxSimp) ? globalThis.Boolean(object.ctxSimp) : undefined,
      liftBool: isSet(object.liftBool) ? liftBoolFromJSON(object.liftBool) : undefined,
      str: isSet(object.str) ? globalThis.Boolean(object.str) : undefined,
    };
  },

  toJSON(message: DecomposeReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assuming !== undefined) {
      obj.assuming = message.assuming;
    }
    if (message.basis?.length) {
      obj.basis = message.basis;
    }
    if (message.ruleSpecs?.length) {
      obj.ruleSpecs = message.ruleSpecs;
    }
    if (message.prune !== false) {
      obj.prune = message.prune;
    }
    if (message.ctxSimp !== undefined) {
      obj.ctxSimp = message.ctxSimp;
    }
    if (message.liftBool !== undefined) {
      obj.liftBool = liftBoolToJSON(message.liftBool);
    }
    if (message.str !== undefined) {
      obj.str = message.str;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecomposeReq>, I>>(base?: I): DecomposeReq {
    return DecomposeReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecomposeReq>, I>>(object: I): DecomposeReq {
    const message = createBaseDecomposeReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.name = object.name ?? "";
    message.assuming = object.assuming ?? undefined;
    message.basis = object.basis?.map((e) => e) || [];
    message.ruleSpecs = object.ruleSpecs?.map((e) => e) || [];
    message.prune = object.prune ?? false;
    message.ctxSimp = object.ctxSimp ?? undefined;
    message.liftBool = object.liftBool ?? undefined;
    message.str = object.str ?? undefined;
    return message;
  },
};

function createBaseDecomposeRes(): DecomposeRes {
  return { artifact: undefined, err: undefined, errors: [], task: undefined };
}

export const DecomposeRes: MessageFns<DecomposeRes> = {
  encode(message: DecomposeRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifact !== undefined) {
      Art.encode(message.artifact, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecomposeRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecomposeRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifact = Art.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecomposeRes {
    return {
      artifact: isSet(object.artifact) ? Art.fromJSON(object.artifact) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: DecomposeRes): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = Art.toJSON(message.artifact);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecomposeRes>, I>>(base?: I): DecomposeRes {
    return DecomposeRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecomposeRes>, I>>(object: I): DecomposeRes {
    const message = createBaseDecomposeRes();
    message.artifact = (object.artifact !== undefined && object.artifact !== null)
      ? Art.fromPartial(object.artifact)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseEvalSrcReq(): EvalSrcReq {
  return { session: undefined, src: "" };
}

export const EvalSrcReq: MessageFns<EvalSrcReq> = {
  encode(message: EvalSrcReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalSrcReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalSrcReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalSrcReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
    };
  },

  toJSON(message: EvalSrcReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalSrcReq>, I>>(base?: I): EvalSrcReq {
    return EvalSrcReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalSrcReq>, I>>(object: I): EvalSrcReq {
    const message = createBaseEvalSrcReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    return message;
  },
};

function createBaseEvalRes(): EvalRes {
  return { success: false, messages: [], errors: [], tasks: [] };
}

export const EvalRes: MessageFns<EvalRes> = {
  encode(message: EvalRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalRes {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => globalThis.String(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
    };
  },

  toJSON(message: EvalRes): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.messages?.length) {
      obj.messages = message.messages;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalRes>, I>>(base?: I): EvalRes {
    return EvalRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalRes>, I>>(object: I): EvalRes {
    const message = createBaseEvalRes();
    message.success = object.success ?? false;
    message.messages = object.messages?.map((e) => e) || [];
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVerifySrcReq(): VerifySrcReq {
  return { session: undefined, src: "", hints: undefined };
}

export const VerifySrcReq: MessageFns<VerifySrcReq> = {
  encode(message: VerifySrcReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifySrcReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifySrcReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifySrcReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: VerifySrcReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifySrcReq>, I>>(base?: I): VerifySrcReq {
    return VerifySrcReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifySrcReq>, I>>(object: I): VerifySrcReq {
    const message = createBaseVerifySrcReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseVerifyNameReq(): VerifyNameReq {
  return { session: undefined, name: "", hints: undefined };
}

export const VerifyNameReq: MessageFns<VerifyNameReq> = {
  encode(message: VerifyNameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyNameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyNameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyNameReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: VerifyNameReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyNameReq>, I>>(base?: I): VerifyNameReq {
    return VerifyNameReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyNameReq>, I>>(object: I): VerifyNameReq {
    const message = createBaseVerifyNameReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.name = object.name ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseInstanceSrcReq(): InstanceSrcReq {
  return { session: undefined, src: "", hints: undefined };
}

export const InstanceSrcReq: MessageFns<InstanceSrcReq> = {
  encode(message: InstanceSrcReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceSrcReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceSrcReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceSrcReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: InstanceSrcReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceSrcReq>, I>>(base?: I): InstanceSrcReq {
    return InstanceSrcReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceSrcReq>, I>>(object: I): InstanceSrcReq {
    const message = createBaseInstanceSrcReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseInstanceNameReq(): InstanceNameReq {
  return { session: undefined, name: "", hints: undefined };
}

export const InstanceNameReq: MessageFns<InstanceNameReq> = {
  encode(message: InstanceNameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceNameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceNameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceNameReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: InstanceNameReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceNameReq>, I>>(base?: I): InstanceNameReq {
    return InstanceNameReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceNameReq>, I>>(object: I): InstanceNameReq {
    const message = createBaseInstanceNameReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.name = object.name ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseProved(): Proved {
  return { proofPp: undefined };
}

export const Proved: MessageFns<Proved> = {
  encode(message: Proved, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofPp !== undefined) {
      writer.uint32(10).string(message.proofPp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Proved {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofPp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Proved {
    return { proofPp: isSet(object.proofPp) ? globalThis.String(object.proofPp) : undefined };
  },

  toJSON(message: Proved): unknown {
    const obj: any = {};
    if (message.proofPp !== undefined) {
      obj.proofPp = message.proofPp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Proved>, I>>(base?: I): Proved {
    return Proved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Proved>, I>>(object: I): Proved {
    const message = createBaseProved();
    message.proofPp = object.proofPp ?? undefined;
    return message;
  },
};

function createBaseUnsat(): Unsat {
  return { proofPp: undefined };
}

export const Unsat: MessageFns<Unsat> = {
  encode(message: Unsat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofPp !== undefined) {
      writer.uint32(10).string(message.proofPp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unsat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofPp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Unsat {
    return { proofPp: isSet(object.proofPp) ? globalThis.String(object.proofPp) : undefined };
  },

  toJSON(message: Unsat): unknown {
    const obj: any = {};
    if (message.proofPp !== undefined) {
      obj.proofPp = message.proofPp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Unsat>, I>>(base?: I): Unsat {
    return Unsat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unsat>, I>>(object: I): Unsat {
    const message = createBaseUnsat();
    message.proofPp = object.proofPp ?? undefined;
    return message;
  },
};

function createBaseModel(): Model {
  return { mType: 0, src: "", artifact: undefined };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mType !== 0) {
      writer.uint32(8).int32(message.mType);
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.artifact !== undefined) {
      Art.encode(message.artifact, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.artifact = Art.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      mType: isSet(object.mType) ? modelTypeFromJSON(object.mType) : 0,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      artifact: isSet(object.artifact) ? Art.fromJSON(object.artifact) : undefined,
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.mType !== 0) {
      obj.mType = modelTypeToJSON(message.mType);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.artifact !== undefined) {
      obj.artifact = Art.toJSON(message.artifact);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Model>, I>>(base?: I): Model {
    return Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {
    const message = createBaseModel();
    message.mType = object.mType ?? 0;
    message.src = object.src ?? "";
    message.artifact = (object.artifact !== undefined && object.artifact !== null)
      ? Art.fromPartial(object.artifact)
      : undefined;
    return message;
  },
};

function createBaseRefuted(): Refuted {
  return { model: undefined };
}

export const Refuted: MessageFns<Refuted> = {
  encode(message: Refuted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Refuted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefuted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Refuted {
    return { model: isSet(object.model) ? Model.fromJSON(object.model) : undefined };
  },

  toJSON(message: Refuted): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Refuted>, I>>(base?: I): Refuted {
    return Refuted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Refuted>, I>>(object: I): Refuted {
    const message = createBaseRefuted();
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseSat(): Sat {
  return { model: undefined };
}

export const Sat: MessageFns<Sat> = {
  encode(message: Sat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sat {
    return { model: isSet(object.model) ? Model.fromJSON(object.model) : undefined };
  },

  toJSON(message: Sat): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Sat>, I>>(base?: I): Sat {
    return Sat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sat>, I>>(object: I): Sat {
    const message = createBaseSat();
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseVerifyRes(): VerifyRes {
  return { unknown: undefined, err: undefined, proved: undefined, refuted: undefined, errors: [], task: undefined };
}

export const VerifyRes: MessageFns<VerifyRes> = {
  encode(message: VerifyRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      StringMsg.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    if (message.proved !== undefined) {
      Proved.encode(message.proved, writer.uint32(26).fork()).join();
    }
    if (message.refuted !== undefined) {
      Refuted.encode(message.refuted, writer.uint32(34).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = StringMsg.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proved = Proved.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refuted = Refuted.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyRes {
    return {
      unknown: isSet(object.unknown) ? StringMsg.fromJSON(object.unknown) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      proved: isSet(object.proved) ? Proved.fromJSON(object.proved) : undefined,
      refuted: isSet(object.refuted) ? Refuted.fromJSON(object.refuted) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: VerifyRes): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = StringMsg.toJSON(message.unknown);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.proved !== undefined) {
      obj.proved = Proved.toJSON(message.proved);
    }
    if (message.refuted !== undefined) {
      obj.refuted = Refuted.toJSON(message.refuted);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyRes>, I>>(base?: I): VerifyRes {
    return VerifyRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyRes>, I>>(object: I): VerifyRes {
    const message = createBaseVerifyRes();
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? StringMsg.fromPartial(object.unknown)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.proved = (object.proved !== undefined && object.proved !== null)
      ? Proved.fromPartial(object.proved)
      : undefined;
    message.refuted = (object.refuted !== undefined && object.refuted !== null)
      ? Refuted.fromPartial(object.refuted)
      : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseInstanceRes(): InstanceRes {
  return { unknown: undefined, err: undefined, unsat: undefined, sat: undefined, errors: [], task: undefined };
}

export const InstanceRes: MessageFns<InstanceRes> = {
  encode(message: InstanceRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      StringMsg.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    if (message.unsat !== undefined) {
      Unsat.encode(message.unsat, writer.uint32(26).fork()).join();
    }
    if (message.sat !== undefined) {
      Sat.encode(message.sat, writer.uint32(34).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = StringMsg.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unsat = Unsat.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sat = Sat.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceRes {
    return {
      unknown: isSet(object.unknown) ? StringMsg.fromJSON(object.unknown) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      unsat: isSet(object.unsat) ? Unsat.fromJSON(object.unsat) : undefined,
      sat: isSet(object.sat) ? Sat.fromJSON(object.sat) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: InstanceRes): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = StringMsg.toJSON(message.unknown);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.unsat !== undefined) {
      obj.unsat = Unsat.toJSON(message.unsat);
    }
    if (message.sat !== undefined) {
      obj.sat = Sat.toJSON(message.sat);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceRes>, I>>(base?: I): InstanceRes {
    return InstanceRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceRes>, I>>(object: I): InstanceRes {
    const message = createBaseInstanceRes();
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? StringMsg.fromPartial(object.unknown)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.unsat = (object.unsat !== undefined && object.unsat !== null) ? Unsat.fromPartial(object.unsat) : undefined;
    message.sat = (object.sat !== undefined && object.sat !== null) ? Sat.fromPartial(object.sat) : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseTypecheckReq(): TypecheckReq {
  return { session: undefined, src: "" };
}

export const TypecheckReq: MessageFns<TypecheckReq> = {
  encode(message: TypecheckReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypecheckReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypecheckReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypecheckReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
    };
  },

  toJSON(message: TypecheckReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypecheckReq>, I>>(base?: I): TypecheckReq {
    return TypecheckReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypecheckReq>, I>>(object: I): TypecheckReq {
    const message = createBaseTypecheckReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    return message;
  },
};

function createBaseTypecheckRes(): TypecheckRes {
  return { success: false, types: "", errors: [] };
}

export const TypecheckRes: MessageFns<TypecheckRes> = {
  encode(message: TypecheckRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.types !== "") {
      writer.uint32(18).string(message.types);
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypecheckRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypecheckRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.types = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypecheckRes {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      types: isSet(object.types) ? globalThis.String(object.types) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
    };
  },

  toJSON(message: TypecheckRes): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.types !== "") {
      obj.types = message.types;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypecheckRes>, I>>(base?: I): TypecheckRes {
    return TypecheckRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypecheckRes>, I>>(object: I): TypecheckRes {
    const message = createBaseTypecheckRes();
    message.success = object.success ?? false;
    message.types = object.types ?? "";
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    return message;
  },
};

export interface Simple {
  /** Get server status */
  status(request: Empty): Promise<StringMsg>;
  /** ask the server to exit */
  shutdown(request: Empty): Promise<Empty>;
  /** create a session easily */
  create_session(request: SessionCreateReq): Promise<Session>;
  /** Terminate a session, do nothing if it doesn't exist */
  end_session(request: Session): Promise<Empty>;
  eval_src(request: EvalSrcReq): Promise<EvalRes>;
  verify_src(request: VerifySrcReq): Promise<VerifyRes>;
  verify_name(request: VerifyNameReq): Promise<VerifyRes>;
  instance_src(request: InstanceSrcReq): Promise<InstanceRes>;
  instance_name(request: InstanceNameReq): Promise<InstanceRes>;
  decompose(request: DecomposeReq): Promise<DecomposeRes>;
  typecheck(request: TypecheckReq): Promise<TypecheckRes>;
}

export const SimpleServiceName = "imandrax.simple.Simple";
export class SimpleClientImpl implements Simple {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SimpleServiceName;
    this.rpc = rpc;
    this.status = this.status.bind(this);
    this.shutdown = this.shutdown.bind(this);
    this.create_session = this.create_session.bind(this);
    this.end_session = this.end_session.bind(this);
    this.eval_src = this.eval_src.bind(this);
    this.verify_src = this.verify_src.bind(this);
    this.verify_name = this.verify_name.bind(this);
    this.instance_src = this.instance_src.bind(this);
    this.instance_name = this.instance_name.bind(this);
    this.decompose = this.decompose.bind(this);
    this.typecheck = this.typecheck.bind(this);
  }
  status(request: Empty): Promise<StringMsg> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "status", data);
    return promise.then((data) => StringMsg.decode(new BinaryReader(data)));
  }

  shutdown(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "shutdown", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  create_session(request: SessionCreateReq): Promise<Session> {
    const data = SessionCreateReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "create_session", data);
    return promise.then((data) => Session.decode(new BinaryReader(data)));
  }

  end_session(request: Session): Promise<Empty> {
    const data = Session.encode(request).finish();
    const promise = this.rpc.request(this.service, "end_session", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  eval_src(request: EvalSrcReq): Promise<EvalRes> {
    const data = EvalSrcReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "eval_src", data);
    return promise.then((data) => EvalRes.decode(new BinaryReader(data)));
  }

  verify_src(request: VerifySrcReq): Promise<VerifyRes> {
    const data = VerifySrcReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "verify_src", data);
    return promise.then((data) => VerifyRes.decode(new BinaryReader(data)));
  }

  verify_name(request: VerifyNameReq): Promise<VerifyRes> {
    const data = VerifyNameReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "verify_name", data);
    return promise.then((data) => VerifyRes.decode(new BinaryReader(data)));
  }

  instance_src(request: InstanceSrcReq): Promise<InstanceRes> {
    const data = InstanceSrcReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "instance_src", data);
    return promise.then((data) => InstanceRes.decode(new BinaryReader(data)));
  }

  instance_name(request: InstanceNameReq): Promise<InstanceRes> {
    const data = InstanceNameReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "instance_name", data);
    return promise.then((data) => InstanceRes.decode(new BinaryReader(data)));
  }

  decompose(request: DecomposeReq): Promise<DecomposeRes> {
    const data = DecomposeReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "decompose", data);
    return promise.then((data) => DecomposeRes.decode(new BinaryReader(data)));
  }

  typecheck(request: TypecheckReq): Promise<TypecheckRes> {
    const data = TypecheckReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "typecheck", data);
    return promise.then((data) => TypecheckRes.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
