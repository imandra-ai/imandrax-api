// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.4
// source: simple_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Art } from "./artmsg.js";
import { Error } from "./error.js";
import { Session } from "./session.js";
import { Origin, Task } from "./task.js";
import { Empty, StringMsg } from "./utils.js";

export const protobufPackage = "imandrax.simple";

export enum LiftBool {
  Default = 0,
  NestedEqualities = 1,
  Equalities = 2,
  All = 3,
  UNRECOGNIZED = -1,
}

export function liftBoolFromJSON(object: any): LiftBool {
  switch (object) {
    case 0:
    case "Default":
      return LiftBool.Default;
    case 1:
    case "NestedEqualities":
      return LiftBool.NestedEqualities;
    case 2:
    case "Equalities":
      return LiftBool.Equalities;
    case 3:
    case "All":
      return LiftBool.All;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LiftBool.UNRECOGNIZED;
  }
}

export function liftBoolToJSON(object: LiftBool): string {
  switch (object) {
    case LiftBool.Default:
      return "Default";
    case LiftBool.NestedEqualities:
      return "NestedEqualities";
    case LiftBool.Equalities:
      return "Equalities";
    case LiftBool.All:
      return "All";
    case LiftBool.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ModelType {
  Counter_example = 0,
  Instance = 1,
  UNRECOGNIZED = -1,
}

export function modelTypeFromJSON(object: any): ModelType {
  switch (object) {
    case 0:
    case "Counter_example":
      return ModelType.Counter_example;
    case 1:
    case "Instance":
      return ModelType.Instance;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelType.UNRECOGNIZED;
  }
}

export function modelTypeToJSON(object: ModelType): string {
  switch (object) {
    case ModelType.Counter_example:
      return "Counter_example";
    case ModelType.Instance:
      return "Instance";
    case ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SessionCreateReq {
  /** the API types version (mandatory) */
  apiVersion: string;
}

export interface DecomposeReq {
  session:
    | Session
    | undefined;
  /** name of function to decompose */
  name: string;
  /** name of side condition function */
  assuming?: string | undefined;
  basis: string[];
  ruleSpecs: string[];
  prune: boolean;
  ctxSimp?: boolean | undefined;
  liftBool?: LiftBool | undefined;
  str?: boolean | undefined;
  timeout?: number | undefined;
}

/** Result of a decomposition */
export interface DecomposeRes {
  artifact?: Art | undefined;
  err?: Empty | undefined;
  errors: Error[];
  /** the ID of the task */
  task: Task | undefined;
}

export interface EvalSrcReq {
  session:
    | Session
    | undefined;
  /** source code to evaluate */
  src: string;
  /**
   * if true, do not wait for tasks results, only return the task list
   * and not the task results. Use `get_artifact` to get the results.
   */
  asyncOnly?: boolean | undefined;
}

/** Output of an "eval" statement */
export interface EvalOutput {
  success: boolean;
  /** result as a OCaml value, if any */
  valueAsOcaml?: string | undefined;
  errors: Error[];
}

export interface EvalRes {
  success: boolean;
  /** "normal" messages */
  messages: string[];
  /** akin to stderr */
  errors: Error[];
  /** all tasks started during eval */
  tasks: Task[];
  poResults: PORes[];
  evalResults: EvalOutput[];
  decompResults: DecomposeRes[];
}

export interface VerifySrcReq {
  session:
    | Session
    | undefined;
  /** source code */
  src: string;
  hints?: string | undefined;
}

export interface VerifyNameReq {
  session:
    | Session
    | undefined;
  /** name of the predicate to verify */
  name: string;
  hints?: string | undefined;
}

export interface InstanceSrcReq {
  session:
    | Session
    | undefined;
  /** source code */
  src: string;
  hints?: string | undefined;
}

export interface InstanceNameReq {
  session:
    | Session
    | undefined;
  /** name of the predicate to verify */
  name: string;
  hints?: string | undefined;
}

export interface Proved {
  proofPp?: string | undefined;
}

export interface VerifiedUpto {
  msg?: string | undefined;
}

export interface Unsat {
  proofPp?: string | undefined;
}

export interface Model {
  mType: ModelType;
  /** iml source code for the model */
  src: string;
  /** the model as an artifact */
  artifact?: Art | undefined;
}

export interface Refuted {
  model?: Model | undefined;
}

export interface Sat {
  model?: Model | undefined;
}

export interface CounterSat {
  model?: Model | undefined;
}

/** Result of any PO (theorem, verify, etc) */
export interface PORes {
  unknown?: StringMsg | undefined;
  err?: Empty | undefined;
  proof?: Proved | undefined;
  instance?: CounterSat | undefined;
  verifiedUpto?: VerifiedUpto | undefined;
  errors: Error[];
  /** the ID of the task */
  task:
    | Task
    | undefined;
  /** Where did the task originate? */
  origin: Origin | undefined;
}

export interface VerifyRes {
  unknown?: StringMsg | undefined;
  err?: Empty | undefined;
  proved?: Proved | undefined;
  refuted?: Refuted | undefined;
  verifiedUpto?: VerifiedUpto | undefined;
  errors: Error[];
  /** the ID of the task */
  task: Task | undefined;
}

export interface InstanceRes {
  unknown?: StringMsg | undefined;
  err?: Empty | undefined;
  unsat?: Unsat | undefined;
  sat?: Sat | undefined;
  errors: Error[];
  /** the ID of the task */
  task: Task | undefined;
}

export interface TypecheckReq {
  session:
    | Session
    | undefined;
  /** source code to evaluate */
  src: string;
}

export interface TypecheckRes {
  success: boolean;
  /** JSON dictionary of inferred types. */
  types: string;
  /** akin to stderr */
  errors: Error[];
}

export interface OneshotReq {
  /** / Some iml code */
  input: string;
}

export interface OneshotRes {
  result: string[];
  errors: string[];
  stats: OneshotRes_Stats | undefined;
  detailedResult: string[];
}

export interface OneshotRes_Stats {
  time: number;
}

function createBaseSessionCreateReq(): SessionCreateReq {
  return { apiVersion: "" };
}

export const SessionCreateReq: MessageFns<SessionCreateReq> = {
  encode(message: SessionCreateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionCreateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionCreateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionCreateReq {
    return { apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "" };
  },

  toJSON(message: SessionCreateReq): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionCreateReq>, I>>(base?: I): SessionCreateReq {
    return SessionCreateReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionCreateReq>, I>>(object: I): SessionCreateReq {
    const message = createBaseSessionCreateReq();
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseDecomposeReq(): DecomposeReq {
  return {
    session: undefined,
    name: "",
    assuming: undefined,
    basis: [],
    ruleSpecs: [],
    prune: false,
    ctxSimp: undefined,
    liftBool: undefined,
    str: undefined,
    timeout: undefined,
  };
}

export const DecomposeReq: MessageFns<DecomposeReq> = {
  encode(message: DecomposeReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.assuming !== undefined) {
      writer.uint32(26).string(message.assuming);
    }
    for (const v of message.basis) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.ruleSpecs) {
      writer.uint32(42).string(v!);
    }
    if (message.prune !== false) {
      writer.uint32(48).bool(message.prune);
    }
    if (message.ctxSimp !== undefined) {
      writer.uint32(56).bool(message.ctxSimp);
    }
    if (message.liftBool !== undefined) {
      writer.uint32(64).int32(message.liftBool);
    }
    if (message.str !== undefined) {
      writer.uint32(72).bool(message.str);
    }
    if (message.timeout !== undefined) {
      writer.uint32(80).int32(message.timeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecomposeReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecomposeReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assuming = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.basis.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ruleSpecs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prune = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ctxSimp = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.liftBool = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.str = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timeout = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecomposeReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assuming: isSet(object.assuming) ? globalThis.String(object.assuming) : undefined,
      basis: globalThis.Array.isArray(object?.basis) ? object.basis.map((e: any) => globalThis.String(e)) : [],
      ruleSpecs: globalThis.Array.isArray(object?.ruleSpecs)
        ? object.ruleSpecs.map((e: any) => globalThis.String(e))
        : [],
      prune: isSet(object.prune) ? globalThis.Boolean(object.prune) : false,
      ctxSimp: isSet(object.ctxSimp) ? globalThis.Boolean(object.ctxSimp) : undefined,
      liftBool: isSet(object.liftBool) ? liftBoolFromJSON(object.liftBool) : undefined,
      str: isSet(object.str) ? globalThis.Boolean(object.str) : undefined,
      timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : undefined,
    };
  },

  toJSON(message: DecomposeReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assuming !== undefined) {
      obj.assuming = message.assuming;
    }
    if (message.basis?.length) {
      obj.basis = message.basis;
    }
    if (message.ruleSpecs?.length) {
      obj.ruleSpecs = message.ruleSpecs;
    }
    if (message.prune !== false) {
      obj.prune = message.prune;
    }
    if (message.ctxSimp !== undefined) {
      obj.ctxSimp = message.ctxSimp;
    }
    if (message.liftBool !== undefined) {
      obj.liftBool = liftBoolToJSON(message.liftBool);
    }
    if (message.str !== undefined) {
      obj.str = message.str;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Math.round(message.timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecomposeReq>, I>>(base?: I): DecomposeReq {
    return DecomposeReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecomposeReq>, I>>(object: I): DecomposeReq {
    const message = createBaseDecomposeReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.name = object.name ?? "";
    message.assuming = object.assuming ?? undefined;
    message.basis = object.basis?.map((e) => e) || [];
    message.ruleSpecs = object.ruleSpecs?.map((e) => e) || [];
    message.prune = object.prune ?? false;
    message.ctxSimp = object.ctxSimp ?? undefined;
    message.liftBool = object.liftBool ?? undefined;
    message.str = object.str ?? undefined;
    message.timeout = object.timeout ?? undefined;
    return message;
  },
};

function createBaseDecomposeRes(): DecomposeRes {
  return { artifact: undefined, err: undefined, errors: [], task: undefined };
}

export const DecomposeRes: MessageFns<DecomposeRes> = {
  encode(message: DecomposeRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifact !== undefined) {
      Art.encode(message.artifact, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecomposeRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecomposeRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifact = Art.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecomposeRes {
    return {
      artifact: isSet(object.artifact) ? Art.fromJSON(object.artifact) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: DecomposeRes): unknown {
    const obj: any = {};
    if (message.artifact !== undefined) {
      obj.artifact = Art.toJSON(message.artifact);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecomposeRes>, I>>(base?: I): DecomposeRes {
    return DecomposeRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecomposeRes>, I>>(object: I): DecomposeRes {
    const message = createBaseDecomposeRes();
    message.artifact = (object.artifact !== undefined && object.artifact !== null)
      ? Art.fromPartial(object.artifact)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseEvalSrcReq(): EvalSrcReq {
  return { session: undefined, src: "", asyncOnly: undefined };
}

export const EvalSrcReq: MessageFns<EvalSrcReq> = {
  encode(message: EvalSrcReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.asyncOnly !== undefined) {
      writer.uint32(24).bool(message.asyncOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalSrcReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalSrcReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.asyncOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalSrcReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      asyncOnly: isSet(object.asyncOnly) ? globalThis.Boolean(object.asyncOnly) : undefined,
    };
  },

  toJSON(message: EvalSrcReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.asyncOnly !== undefined) {
      obj.asyncOnly = message.asyncOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalSrcReq>, I>>(base?: I): EvalSrcReq {
    return EvalSrcReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalSrcReq>, I>>(object: I): EvalSrcReq {
    const message = createBaseEvalSrcReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    message.asyncOnly = object.asyncOnly ?? undefined;
    return message;
  },
};

function createBaseEvalOutput(): EvalOutput {
  return { success: false, valueAsOcaml: undefined, errors: [] };
}

export const EvalOutput: MessageFns<EvalOutput> = {
  encode(message: EvalOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.valueAsOcaml !== undefined) {
      writer.uint32(18).string(message.valueAsOcaml);
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.valueAsOcaml = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalOutput {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      valueAsOcaml: isSet(object.valueAsOcaml) ? globalThis.String(object.valueAsOcaml) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
    };
  },

  toJSON(message: EvalOutput): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.valueAsOcaml !== undefined) {
      obj.valueAsOcaml = message.valueAsOcaml;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalOutput>, I>>(base?: I): EvalOutput {
    return EvalOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalOutput>, I>>(object: I): EvalOutput {
    const message = createBaseEvalOutput();
    message.success = object.success ?? false;
    message.valueAsOcaml = object.valueAsOcaml ?? undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvalRes(): EvalRes {
  return { success: false, messages: [], errors: [], tasks: [], poResults: [], evalResults: [], decompResults: [] };
}

export const EvalRes: MessageFns<EvalRes> = {
  encode(message: EvalRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.poResults) {
      PORes.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.evalResults) {
      EvalOutput.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.decompResults) {
      DecomposeRes.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.poResults.push(PORes.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.evalResults.push(EvalOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.decompResults.push(DecomposeRes.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalRes {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => globalThis.String(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
      poResults: globalThis.Array.isArray(object?.poResults) ? object.poResults.map((e: any) => PORes.fromJSON(e)) : [],
      evalResults: globalThis.Array.isArray(object?.evalResults)
        ? object.evalResults.map((e: any) => EvalOutput.fromJSON(e))
        : [],
      decompResults: globalThis.Array.isArray(object?.decompResults)
        ? object.decompResults.map((e: any) => DecomposeRes.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EvalRes): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.messages?.length) {
      obj.messages = message.messages;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.poResults?.length) {
      obj.poResults = message.poResults.map((e) => PORes.toJSON(e));
    }
    if (message.evalResults?.length) {
      obj.evalResults = message.evalResults.map((e) => EvalOutput.toJSON(e));
    }
    if (message.decompResults?.length) {
      obj.decompResults = message.decompResults.map((e) => DecomposeRes.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalRes>, I>>(base?: I): EvalRes {
    return EvalRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalRes>, I>>(object: I): EvalRes {
    const message = createBaseEvalRes();
    message.success = object.success ?? false;
    message.messages = object.messages?.map((e) => e) || [];
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.poResults = object.poResults?.map((e) => PORes.fromPartial(e)) || [];
    message.evalResults = object.evalResults?.map((e) => EvalOutput.fromPartial(e)) || [];
    message.decompResults = object.decompResults?.map((e) => DecomposeRes.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVerifySrcReq(): VerifySrcReq {
  return { session: undefined, src: "", hints: undefined };
}

export const VerifySrcReq: MessageFns<VerifySrcReq> = {
  encode(message: VerifySrcReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifySrcReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifySrcReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifySrcReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: VerifySrcReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifySrcReq>, I>>(base?: I): VerifySrcReq {
    return VerifySrcReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifySrcReq>, I>>(object: I): VerifySrcReq {
    const message = createBaseVerifySrcReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseVerifyNameReq(): VerifyNameReq {
  return { session: undefined, name: "", hints: undefined };
}

export const VerifyNameReq: MessageFns<VerifyNameReq> = {
  encode(message: VerifyNameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyNameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyNameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyNameReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: VerifyNameReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyNameReq>, I>>(base?: I): VerifyNameReq {
    return VerifyNameReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyNameReq>, I>>(object: I): VerifyNameReq {
    const message = createBaseVerifyNameReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.name = object.name ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseInstanceSrcReq(): InstanceSrcReq {
  return { session: undefined, src: "", hints: undefined };
}

export const InstanceSrcReq: MessageFns<InstanceSrcReq> = {
  encode(message: InstanceSrcReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceSrcReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceSrcReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceSrcReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: InstanceSrcReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceSrcReq>, I>>(base?: I): InstanceSrcReq {
    return InstanceSrcReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceSrcReq>, I>>(object: I): InstanceSrcReq {
    const message = createBaseInstanceSrcReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseInstanceNameReq(): InstanceNameReq {
  return { session: undefined, name: "", hints: undefined };
}

export const InstanceNameReq: MessageFns<InstanceNameReq> = {
  encode(message: InstanceNameReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.hints !== undefined) {
      writer.uint32(82).string(message.hints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceNameReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceNameReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hints = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceNameReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hints: isSet(object.hints) ? globalThis.String(object.hints) : undefined,
    };
  },

  toJSON(message: InstanceNameReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hints !== undefined) {
      obj.hints = message.hints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceNameReq>, I>>(base?: I): InstanceNameReq {
    return InstanceNameReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceNameReq>, I>>(object: I): InstanceNameReq {
    const message = createBaseInstanceNameReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.name = object.name ?? "";
    message.hints = object.hints ?? undefined;
    return message;
  },
};

function createBaseProved(): Proved {
  return { proofPp: undefined };
}

export const Proved: MessageFns<Proved> = {
  encode(message: Proved, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofPp !== undefined) {
      writer.uint32(10).string(message.proofPp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Proved {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofPp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Proved {
    return { proofPp: isSet(object.proofPp) ? globalThis.String(object.proofPp) : undefined };
  },

  toJSON(message: Proved): unknown {
    const obj: any = {};
    if (message.proofPp !== undefined) {
      obj.proofPp = message.proofPp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Proved>, I>>(base?: I): Proved {
    return Proved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Proved>, I>>(object: I): Proved {
    const message = createBaseProved();
    message.proofPp = object.proofPp ?? undefined;
    return message;
  },
};

function createBaseVerifiedUpto(): VerifiedUpto {
  return { msg: undefined };
}

export const VerifiedUpto: MessageFns<VerifiedUpto> = {
  encode(message: VerifiedUpto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      writer.uint32(10).string(message.msg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifiedUpto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifiedUpto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifiedUpto {
    return { msg: isSet(object.msg) ? globalThis.String(object.msg) : undefined };
  },

  toJSON(message: VerifiedUpto): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifiedUpto>, I>>(base?: I): VerifiedUpto {
    return VerifiedUpto.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifiedUpto>, I>>(object: I): VerifiedUpto {
    const message = createBaseVerifiedUpto();
    message.msg = object.msg ?? undefined;
    return message;
  },
};

function createBaseUnsat(): Unsat {
  return { proofPp: undefined };
}

export const Unsat: MessageFns<Unsat> = {
  encode(message: Unsat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofPp !== undefined) {
      writer.uint32(10).string(message.proofPp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unsat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofPp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Unsat {
    return { proofPp: isSet(object.proofPp) ? globalThis.String(object.proofPp) : undefined };
  },

  toJSON(message: Unsat): unknown {
    const obj: any = {};
    if (message.proofPp !== undefined) {
      obj.proofPp = message.proofPp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Unsat>, I>>(base?: I): Unsat {
    return Unsat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unsat>, I>>(object: I): Unsat {
    const message = createBaseUnsat();
    message.proofPp = object.proofPp ?? undefined;
    return message;
  },
};

function createBaseModel(): Model {
  return { mType: 0, src: "", artifact: undefined };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mType !== 0) {
      writer.uint32(8).int32(message.mType);
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.artifact !== undefined) {
      Art.encode(message.artifact, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.artifact = Art.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      mType: isSet(object.mType) ? modelTypeFromJSON(object.mType) : 0,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      artifact: isSet(object.artifact) ? Art.fromJSON(object.artifact) : undefined,
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.mType !== 0) {
      obj.mType = modelTypeToJSON(message.mType);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.artifact !== undefined) {
      obj.artifact = Art.toJSON(message.artifact);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Model>, I>>(base?: I): Model {
    return Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {
    const message = createBaseModel();
    message.mType = object.mType ?? 0;
    message.src = object.src ?? "";
    message.artifact = (object.artifact !== undefined && object.artifact !== null)
      ? Art.fromPartial(object.artifact)
      : undefined;
    return message;
  },
};

function createBaseRefuted(): Refuted {
  return { model: undefined };
}

export const Refuted: MessageFns<Refuted> = {
  encode(message: Refuted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Refuted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefuted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Refuted {
    return { model: isSet(object.model) ? Model.fromJSON(object.model) : undefined };
  },

  toJSON(message: Refuted): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Refuted>, I>>(base?: I): Refuted {
    return Refuted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Refuted>, I>>(object: I): Refuted {
    const message = createBaseRefuted();
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseSat(): Sat {
  return { model: undefined };
}

export const Sat: MessageFns<Sat> = {
  encode(message: Sat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sat {
    return { model: isSet(object.model) ? Model.fromJSON(object.model) : undefined };
  },

  toJSON(message: Sat): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Sat>, I>>(base?: I): Sat {
    return Sat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sat>, I>>(object: I): Sat {
    const message = createBaseSat();
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseCounterSat(): CounterSat {
  return { model: undefined };
}

export const CounterSat: MessageFns<CounterSat> = {
  encode(message: CounterSat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CounterSat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterSat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterSat {
    return { model: isSet(object.model) ? Model.fromJSON(object.model) : undefined };
  },

  toJSON(message: CounterSat): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CounterSat>, I>>(base?: I): CounterSat {
    return CounterSat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CounterSat>, I>>(object: I): CounterSat {
    const message = createBaseCounterSat();
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBasePORes(): PORes {
  return {
    unknown: undefined,
    err: undefined,
    proof: undefined,
    instance: undefined,
    verifiedUpto: undefined,
    errors: [],
    task: undefined,
    origin: undefined,
  };
}

export const PORes: MessageFns<PORes> = {
  encode(message: PORes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      StringMsg.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    if (message.proof !== undefined) {
      Proved.encode(message.proof, writer.uint32(26).fork()).join();
    }
    if (message.instance !== undefined) {
      CounterSat.encode(message.instance, writer.uint32(34).fork()).join();
    }
    if (message.verifiedUpto !== undefined) {
      VerifiedUpto.encode(message.verifiedUpto, writer.uint32(42).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    if (message.origin !== undefined) {
      Origin.encode(message.origin, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PORes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePORes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = StringMsg.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = Proved.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instance = CounterSat.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.verifiedUpto = VerifiedUpto.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.origin = Origin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PORes {
    return {
      unknown: isSet(object.unknown) ? StringMsg.fromJSON(object.unknown) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      proof: isSet(object.proof) ? Proved.fromJSON(object.proof) : undefined,
      instance: isSet(object.instance) ? CounterSat.fromJSON(object.instance) : undefined,
      verifiedUpto: isSet(object.verifiedUpto) ? VerifiedUpto.fromJSON(object.verifiedUpto) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      origin: isSet(object.origin) ? Origin.fromJSON(object.origin) : undefined,
    };
  },

  toJSON(message: PORes): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = StringMsg.toJSON(message.unknown);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.proof !== undefined) {
      obj.proof = Proved.toJSON(message.proof);
    }
    if (message.instance !== undefined) {
      obj.instance = CounterSat.toJSON(message.instance);
    }
    if (message.verifiedUpto !== undefined) {
      obj.verifiedUpto = VerifiedUpto.toJSON(message.verifiedUpto);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.origin !== undefined) {
      obj.origin = Origin.toJSON(message.origin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PORes>, I>>(base?: I): PORes {
    return PORes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PORes>, I>>(object: I): PORes {
    const message = createBasePORes();
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? StringMsg.fromPartial(object.unknown)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? Proved.fromPartial(object.proof)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? CounterSat.fromPartial(object.instance)
      : undefined;
    message.verifiedUpto = (object.verifiedUpto !== undefined && object.verifiedUpto !== null)
      ? VerifiedUpto.fromPartial(object.verifiedUpto)
      : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? Origin.fromPartial(object.origin)
      : undefined;
    return message;
  },
};

function createBaseVerifyRes(): VerifyRes {
  return {
    unknown: undefined,
    err: undefined,
    proved: undefined,
    refuted: undefined,
    verifiedUpto: undefined,
    errors: [],
    task: undefined,
  };
}

export const VerifyRes: MessageFns<VerifyRes> = {
  encode(message: VerifyRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      StringMsg.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    if (message.proved !== undefined) {
      Proved.encode(message.proved, writer.uint32(26).fork()).join();
    }
    if (message.refuted !== undefined) {
      Refuted.encode(message.refuted, writer.uint32(34).fork()).join();
    }
    if (message.verifiedUpto !== undefined) {
      VerifiedUpto.encode(message.verifiedUpto, writer.uint32(42).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = StringMsg.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proved = Proved.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refuted = Refuted.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.verifiedUpto = VerifiedUpto.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyRes {
    return {
      unknown: isSet(object.unknown) ? StringMsg.fromJSON(object.unknown) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      proved: isSet(object.proved) ? Proved.fromJSON(object.proved) : undefined,
      refuted: isSet(object.refuted) ? Refuted.fromJSON(object.refuted) : undefined,
      verifiedUpto: isSet(object.verifiedUpto) ? VerifiedUpto.fromJSON(object.verifiedUpto) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: VerifyRes): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = StringMsg.toJSON(message.unknown);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.proved !== undefined) {
      obj.proved = Proved.toJSON(message.proved);
    }
    if (message.refuted !== undefined) {
      obj.refuted = Refuted.toJSON(message.refuted);
    }
    if (message.verifiedUpto !== undefined) {
      obj.verifiedUpto = VerifiedUpto.toJSON(message.verifiedUpto);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyRes>, I>>(base?: I): VerifyRes {
    return VerifyRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyRes>, I>>(object: I): VerifyRes {
    const message = createBaseVerifyRes();
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? StringMsg.fromPartial(object.unknown)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.proved = (object.proved !== undefined && object.proved !== null)
      ? Proved.fromPartial(object.proved)
      : undefined;
    message.refuted = (object.refuted !== undefined && object.refuted !== null)
      ? Refuted.fromPartial(object.refuted)
      : undefined;
    message.verifiedUpto = (object.verifiedUpto !== undefined && object.verifiedUpto !== null)
      ? VerifiedUpto.fromPartial(object.verifiedUpto)
      : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseInstanceRes(): InstanceRes {
  return { unknown: undefined, err: undefined, unsat: undefined, sat: undefined, errors: [], task: undefined };
}

export const InstanceRes: MessageFns<InstanceRes> = {
  encode(message: InstanceRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      StringMsg.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.err !== undefined) {
      Empty.encode(message.err, writer.uint32(18).fork()).join();
    }
    if (message.unsat !== undefined) {
      Unsat.encode(message.unsat, writer.uint32(26).fork()).join();
    }
    if (message.sat !== undefined) {
      Sat.encode(message.sat, writer.uint32(34).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = StringMsg.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.err = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unsat = Unsat.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sat = Sat.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceRes {
    return {
      unknown: isSet(object.unknown) ? StringMsg.fromJSON(object.unknown) : undefined,
      err: isSet(object.err) ? Empty.fromJSON(object.err) : undefined,
      unsat: isSet(object.unsat) ? Unsat.fromJSON(object.unsat) : undefined,
      sat: isSet(object.sat) ? Sat.fromJSON(object.sat) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: InstanceRes): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = StringMsg.toJSON(message.unknown);
    }
    if (message.err !== undefined) {
      obj.err = Empty.toJSON(message.err);
    }
    if (message.unsat !== undefined) {
      obj.unsat = Unsat.toJSON(message.unsat);
    }
    if (message.sat !== undefined) {
      obj.sat = Sat.toJSON(message.sat);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceRes>, I>>(base?: I): InstanceRes {
    return InstanceRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceRes>, I>>(object: I): InstanceRes {
    const message = createBaseInstanceRes();
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? StringMsg.fromPartial(object.unknown)
      : undefined;
    message.err = (object.err !== undefined && object.err !== null) ? Empty.fromPartial(object.err) : undefined;
    message.unsat = (object.unsat !== undefined && object.unsat !== null) ? Unsat.fromPartial(object.unsat) : undefined;
    message.sat = (object.sat !== undefined && object.sat !== null) ? Sat.fromPartial(object.sat) : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseTypecheckReq(): TypecheckReq {
  return { session: undefined, src: "" };
}

export const TypecheckReq: MessageFns<TypecheckReq> = {
  encode(message: TypecheckReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypecheckReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypecheckReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypecheckReq {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      src: isSet(object.src) ? globalThis.String(object.src) : "",
    };
  },

  toJSON(message: TypecheckReq): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypecheckReq>, I>>(base?: I): TypecheckReq {
    return TypecheckReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypecheckReq>, I>>(object: I): TypecheckReq {
    const message = createBaseTypecheckReq();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.src = object.src ?? "";
    return message;
  },
};

function createBaseTypecheckRes(): TypecheckRes {
  return { success: false, types: "", errors: [] };
}

export const TypecheckRes: MessageFns<TypecheckRes> = {
  encode(message: TypecheckRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.types !== "") {
      writer.uint32(18).string(message.types);
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypecheckRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypecheckRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.types = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypecheckRes {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      types: isSet(object.types) ? globalThis.String(object.types) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
    };
  },

  toJSON(message: TypecheckRes): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.types !== "") {
      obj.types = message.types;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypecheckRes>, I>>(base?: I): TypecheckRes {
    return TypecheckRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypecheckRes>, I>>(object: I): TypecheckRes {
    const message = createBaseTypecheckRes();
    message.success = object.success ?? false;
    message.types = object.types ?? "";
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOneshotReq(): OneshotReq {
  return { input: "" };
}

export const OneshotReq: MessageFns<OneshotReq> = {
  encode(message: OneshotReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneshotReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneshotReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneshotReq {
    return { input: isSet(object.input) ? globalThis.String(object.input) : "" };
  },

  toJSON(message: OneshotReq): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OneshotReq>, I>>(base?: I): OneshotReq {
    return OneshotReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OneshotReq>, I>>(object: I): OneshotReq {
    const message = createBaseOneshotReq();
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseOneshotRes(): OneshotRes {
  return { result: [], errors: [], stats: undefined, detailedResult: [] };
}

export const OneshotRes: MessageFns<OneshotRes> = {
  encode(message: OneshotRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.result) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.errors) {
      writer.uint32(18).string(v!);
    }
    if (message.stats !== undefined) {
      OneshotRes_Stats.encode(message.stats, writer.uint32(26).fork()).join();
    }
    for (const v of message.detailedResult) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneshotRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneshotRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stats = OneshotRes_Stats.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.detailedResult.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneshotRes {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => globalThis.String(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
      stats: isSet(object.stats) ? OneshotRes_Stats.fromJSON(object.stats) : undefined,
      detailedResult: globalThis.Array.isArray(object?.detailedResult)
        ? object.detailedResult.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OneshotRes): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result;
    }
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    if (message.stats !== undefined) {
      obj.stats = OneshotRes_Stats.toJSON(message.stats);
    }
    if (message.detailedResult?.length) {
      obj.detailedResult = message.detailedResult;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OneshotRes>, I>>(base?: I): OneshotRes {
    return OneshotRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OneshotRes>, I>>(object: I): OneshotRes {
    const message = createBaseOneshotRes();
    message.result = object.result?.map((e) => e) || [];
    message.errors = object.errors?.map((e) => e) || [];
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? OneshotRes_Stats.fromPartial(object.stats)
      : undefined;
    message.detailedResult = object.detailedResult?.map((e) => e) || [];
    return message;
  },
};

function createBaseOneshotRes_Stats(): OneshotRes_Stats {
  return { time: 0 };
}

export const OneshotRes_Stats: MessageFns<OneshotRes_Stats> = {
  encode(message: OneshotRes_Stats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== 0) {
      writer.uint32(9).double(message.time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneshotRes_Stats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneshotRes_Stats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.time = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneshotRes_Stats {
    return { time: isSet(object.time) ? globalThis.Number(object.time) : 0 };
  },

  toJSON(message: OneshotRes_Stats): unknown {
    const obj: any = {};
    if (message.time !== 0) {
      obj.time = message.time;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OneshotRes_Stats>, I>>(base?: I): OneshotRes_Stats {
    return OneshotRes_Stats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OneshotRes_Stats>, I>>(object: I): OneshotRes_Stats {
    const message = createBaseOneshotRes_Stats();
    message.time = object.time ?? 0;
    return message;
  },
};

export interface Simple {
  /** Get server status */
  status(request: Empty): Promise<StringMsg>;
  /** ask the server to exit */
  shutdown(request: Empty): Promise<Empty>;
  /** create a session easily */
  create_session(request: SessionCreateReq): Promise<Session>;
  /** Terminate a session, do nothing if it doesn't exist */
  end_session(request: Session): Promise<Empty>;
  eval_src(request: EvalSrcReq): Promise<EvalRes>;
  verify_src(request: VerifySrcReq): Promise<VerifyRes>;
  verify_name(request: VerifyNameReq): Promise<VerifyRes>;
  instance_src(request: InstanceSrcReq): Promise<InstanceRes>;
  instance_name(request: InstanceNameReq): Promise<InstanceRes>;
  decompose(request: DecomposeReq): Promise<DecomposeRes>;
  typecheck(request: TypecheckReq): Promise<TypecheckRes>;
  /** Sessionless, self contained request/response */
  oneshot(request: OneshotReq): Promise<OneshotRes>;
}

export const SimpleServiceName = "imandrax.simple.Simple";
export class SimpleClientImpl implements Simple {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SimpleServiceName;
    this.rpc = rpc;
    this.status = this.status.bind(this);
    this.shutdown = this.shutdown.bind(this);
    this.create_session = this.create_session.bind(this);
    this.end_session = this.end_session.bind(this);
    this.eval_src = this.eval_src.bind(this);
    this.verify_src = this.verify_src.bind(this);
    this.verify_name = this.verify_name.bind(this);
    this.instance_src = this.instance_src.bind(this);
    this.instance_name = this.instance_name.bind(this);
    this.decompose = this.decompose.bind(this);
    this.typecheck = this.typecheck.bind(this);
    this.oneshot = this.oneshot.bind(this);
  }
  status(request: Empty): Promise<StringMsg> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "status", data);
    return promise.then((data) => StringMsg.decode(new BinaryReader(data)));
  }

  shutdown(request: Empty): Promise<Empty> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "shutdown", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  create_session(request: SessionCreateReq): Promise<Session> {
    const data = SessionCreateReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "create_session", data);
    return promise.then((data) => Session.decode(new BinaryReader(data)));
  }

  end_session(request: Session): Promise<Empty> {
    const data = Session.encode(request).finish();
    const promise = this.rpc.request(this.service, "end_session", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  eval_src(request: EvalSrcReq): Promise<EvalRes> {
    const data = EvalSrcReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "eval_src", data);
    return promise.then((data) => EvalRes.decode(new BinaryReader(data)));
  }

  verify_src(request: VerifySrcReq): Promise<VerifyRes> {
    const data = VerifySrcReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "verify_src", data);
    return promise.then((data) => VerifyRes.decode(new BinaryReader(data)));
  }

  verify_name(request: VerifyNameReq): Promise<VerifyRes> {
    const data = VerifyNameReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "verify_name", data);
    return promise.then((data) => VerifyRes.decode(new BinaryReader(data)));
  }

  instance_src(request: InstanceSrcReq): Promise<InstanceRes> {
    const data = InstanceSrcReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "instance_src", data);
    return promise.then((data) => InstanceRes.decode(new BinaryReader(data)));
  }

  instance_name(request: InstanceNameReq): Promise<InstanceRes> {
    const data = InstanceNameReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "instance_name", data);
    return promise.then((data) => InstanceRes.decode(new BinaryReader(data)));
  }

  decompose(request: DecomposeReq): Promise<DecomposeRes> {
    const data = DecomposeReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "decompose", data);
    return promise.then((data) => DecomposeRes.decode(new BinaryReader(data)));
  }

  typecheck(request: TypecheckReq): Promise<TypecheckRes> {
    const data = TypecheckReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "typecheck", data);
    return promise.then((data) => TypecheckRes.decode(new BinaryReader(data)));
  }

  oneshot(request: OneshotReq): Promise<OneshotRes> {
    const data = OneshotReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "oneshot", data);
    return promise.then((data) => OneshotRes.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
