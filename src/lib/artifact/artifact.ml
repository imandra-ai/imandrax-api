
(* this file is autogenerated, do not edit *)

open struct
  let spf = Printf.sprintf
end

module Mir = Imandrax_api_mir
module Task = Imandrax_api_tasks

(** The kind of artifact. *)
type _ kind =
| Term : Imandrax_api_mir.Term.t kind
(** A MIR term *)
| Type : Imandrax_api_mir.Type.t kind
(** A MIR type *)
| PO_task : Imandrax_api_tasks.PO_task.Mir.t kind
(** Task to verify a Proof Obligation *)
| PO_res : Imandrax_api_tasks.PO_res.Shallow.t kind
(** Result of verifying a PO *)
| Eval_task : Imandrax_api_tasks.Eval_task.Mir.t kind
(** Task to evaluate a term *)
| Eval_res : Imandrax_api_tasks.Eval_res.t kind
(** Result of evaluating a term *)
| Model : Imandrax_api_mir.Model.t kind
(** A MIR-level model *)
| Show : string kind
(** A human readable description *)
| Fun_decomp : Imandrax_api_mir.Fun_decomp.t kind
(** A MIR-level function decomposition *)
| Decomp_task : Imandrax_api_tasks.Decomp_task.Mir.t kind
(** Task to decompose a function *)
| Decomp_res : Imandrax_api_tasks.Decomp_res.Shallow.t kind
(** Result of decomposing a function *)
| Report : Imandrax_api_report.Report.t kind
(** Report from some task *)


let kind_to_string : type a. a kind -> string = function
  | Term -> "term"
  | Type -> "ty"
  | PO_task -> "po_task"
  | PO_res -> "po_res"
  | Eval_task -> "eval_task"
  | Eval_res -> "eval_res"
  | Model -> "mir.model"
  | Show -> "show"
  | Fun_decomp -> "mir.fun_decomp"
  | Decomp_task -> "decomp_task"
  | Decomp_res -> "decomp_res"
  | Report -> "report"


(** A type erased kind. *)
type any_kind = Any_kind : _ kind -> any_kind

let any_kind_to_string (Any_kind k) : string = kind_to_string k

let kind_of_string : string -> (any_kind, string) result = function
  | "term" -> Ok (Any_kind Term)
  | "ty" -> Ok (Any_kind Type)
  | "po_task" -> Ok (Any_kind PO_task)
  | "po_res" -> Ok (Any_kind PO_res)
  | "eval_task" -> Ok (Any_kind Eval_task)
  | "eval_res" -> Ok (Any_kind Eval_res)
  | "mir.model" -> Ok (Any_kind Model)
  | "show" -> Ok (Any_kind Show)
  | "mir.fun_decomp" -> Ok (Any_kind Fun_decomp)
  | "decomp_task" -> Ok (Any_kind Decomp_task)
  | "decomp_res" -> Ok (Any_kind Decomp_res)
  | "report" -> Ok (Any_kind Report)
  | s -> Error (spf {|Unknown artifact kind: %S|} s)


let is_term : string -> bool = fun str -> str = "term"
let is_type : string -> bool = fun str -> str = "ty"
let is_po_task : string -> bool = fun str -> str = "po_task"
let is_po_res : string -> bool = fun str -> str = "po_res"
let is_eval_task : string -> bool = fun str -> str = "eval_task"
let is_eval_res : string -> bool = fun str -> str = "eval_res"
let is_model : string -> bool = fun str -> str = "mir.model"
let is_show : string -> bool = fun str -> str = "show"
let is_fun_decomp : string -> bool = fun str -> str = "mir.fun_decomp"
let is_decomp_task : string -> bool = fun str -> str = "decomp_task"
let is_decomp_res : string -> bool = fun str -> str = "decomp_res"
let is_report : string -> bool = fun str -> str = "report"

type storage = (Imandrax_api_ca_store.Key.t * (bytes [@use_bytes])) list
[@@deriving twine]

(** An artifact. *)
type t = Artifact : {
  kind: 'a kind;
    (** Kind of artifact *)
  data: 'a;
    (** Main data *)
  storage: storage;
    (** Additional storage *)
} -> t

(** Pack together an artifact *)
  let[@inline] make ~storage ~kind data : t = Artifact {kind; data; storage}

let[@inline] make_term ?(storage=[]) : Imandrax_api_mir.Term.t -> t = fun x -> make ~storage ~kind:Term x

let as_term : t -> Imandrax_api_mir.Term.t option = function
  | Artifact {kind=Term; data=x; _} -> Some x
  | _ -> None

let[@inline] make_type ?(storage=[]) : Imandrax_api_mir.Type.t -> t = fun x -> make ~storage ~kind:Type x

let as_type : t -> Imandrax_api_mir.Type.t option = function
  | Artifact {kind=Type; data=x; _} -> Some x
  | _ -> None

let[@inline] make_po_task ?(storage=[]) : Imandrax_api_tasks.PO_task.Mir.t -> t = fun x -> make ~storage ~kind:PO_task x

let as_po_task : t -> Imandrax_api_tasks.PO_task.Mir.t option = function
  | Artifact {kind=PO_task; data=x; _} -> Some x
  | _ -> None

let[@inline] make_po_res ?(storage=[]) : Imandrax_api_tasks.PO_res.Shallow.t -> t = fun x -> make ~storage ~kind:PO_res x

let as_po_res : t -> Imandrax_api_tasks.PO_res.Shallow.t option = function
  | Artifact {kind=PO_res; data=x; _} -> Some x
  | _ -> None

let[@inline] make_eval_task ?(storage=[]) : Imandrax_api_tasks.Eval_task.Mir.t -> t = fun x -> make ~storage ~kind:Eval_task x

let as_eval_task : t -> Imandrax_api_tasks.Eval_task.Mir.t option = function
  | Artifact {kind=Eval_task; data=x; _} -> Some x
  | _ -> None

let[@inline] make_eval_res ?(storage=[]) : Imandrax_api_tasks.Eval_res.t -> t = fun x -> make ~storage ~kind:Eval_res x

let as_eval_res : t -> Imandrax_api_tasks.Eval_res.t option = function
  | Artifact {kind=Eval_res; data=x; _} -> Some x
  | _ -> None

let[@inline] make_model ?(storage=[]) : Imandrax_api_mir.Model.t -> t = fun x -> make ~storage ~kind:Model x

let as_model : t -> Imandrax_api_mir.Model.t option = function
  | Artifact {kind=Model; data=x; _} -> Some x
  | _ -> None

let[@inline] make_show ?(storage=[]) : string -> t = fun x -> make ~storage ~kind:Show x

let as_show : t -> string option = function
  | Artifact {kind=Show; data=x; _} -> Some x
  | _ -> None

let[@inline] make_fun_decomp ?(storage=[]) : Imandrax_api_mir.Fun_decomp.t -> t = fun x -> make ~storage ~kind:Fun_decomp x

let as_fun_decomp : t -> Imandrax_api_mir.Fun_decomp.t option = function
  | Artifact {kind=Fun_decomp; data=x; _} -> Some x
  | _ -> None

let[@inline] make_decomp_task ?(storage=[]) : Imandrax_api_tasks.Decomp_task.Mir.t -> t = fun x -> make ~storage ~kind:Decomp_task x

let as_decomp_task : t -> Imandrax_api_tasks.Decomp_task.Mir.t option = function
  | Artifact {kind=Decomp_task; data=x; _} -> Some x
  | _ -> None

let[@inline] make_decomp_res ?(storage=[]) : Imandrax_api_tasks.Decomp_res.Shallow.t -> t = fun x -> make ~storage ~kind:Decomp_res x

let as_decomp_res : t -> Imandrax_api_tasks.Decomp_res.Shallow.t option = function
  | Artifact {kind=Decomp_res; data=x; _} -> Some x
  | _ -> None

let[@inline] make_report ?(storage=[]) : Imandrax_api_report.Report.t -> t = fun x -> make ~storage ~kind:Report x

let as_report : t -> Imandrax_api_report.Report.t option = function
  | Artifact {kind=Report; data=x; _} -> Some x
  | _ -> None

let to_twine : t Imandrakit_twine.Encode.encoder = fun enc (Artifact {kind; data=x; storage=_}) -> match kind with
|  Term -> Imandrax_api_mir.Term.to_twine enc x
|  Type -> Imandrax_api_mir.Type.to_twine enc x
|  PO_task -> Imandrax_api_tasks.PO_task.Mir.to_twine enc x
|  PO_res -> Imandrax_api_tasks.PO_res.Shallow.to_twine enc x
|  Eval_task -> Imandrax_api_tasks.Eval_task.Mir.to_twine enc x
|  Eval_res -> Imandrax_api_tasks.Eval_res.to_twine enc x
|  Model -> Imandrax_api_mir.Model.to_twine enc x
|  Show -> (fun _enc s -> Imandrakit_twine.Immediate.string s) enc x
|  Fun_decomp -> Imandrax_api_mir.Fun_decomp.to_twine enc x
|  Decomp_task -> Imandrax_api_tasks.Decomp_task.Mir.to_twine enc x
|  Decomp_res -> Imandrax_api_tasks.Decomp_res.Shallow.to_twine enc x
|  Report -> Imandrax_api_report.Report.to_twine enc x

let term_of_twine : Imandrax_api_mir.Term.t Imandrakit_twine.Decode.decoder = Imandrax_api_mir.Term.of_twine

let type_of_twine : Imandrax_api_mir.Type.t Imandrakit_twine.Decode.decoder = Imandrax_api_mir.Type.of_twine

let po_task_of_twine : Imandrax_api_tasks.PO_task.Mir.t Imandrakit_twine.Decode.decoder = Imandrax_api_tasks.PO_task.Mir.of_twine

let po_res_of_twine : Imandrax_api_tasks.PO_res.Shallow.t Imandrakit_twine.Decode.decoder = Imandrax_api_tasks.PO_res.Shallow.of_twine

let eval_task_of_twine : Imandrax_api_tasks.Eval_task.Mir.t Imandrakit_twine.Decode.decoder = Imandrax_api_tasks.Eval_task.Mir.of_twine

let eval_res_of_twine : Imandrax_api_tasks.Eval_res.t Imandrakit_twine.Decode.decoder = Imandrax_api_tasks.Eval_res.of_twine

let model_of_twine : Imandrax_api_mir.Model.t Imandrakit_twine.Decode.decoder = Imandrax_api_mir.Model.of_twine

let show_of_twine : string Imandrakit_twine.Decode.decoder = (fun d i -> Imandrakit_twine.Decode.(string d @@ deref_rec d i))

let fun_decomp_of_twine : Imandrax_api_mir.Fun_decomp.t Imandrakit_twine.Decode.decoder = Imandrax_api_mir.Fun_decomp.of_twine

let decomp_task_of_twine : Imandrax_api_tasks.Decomp_task.Mir.t Imandrakit_twine.Decode.decoder = Imandrax_api_tasks.Decomp_task.Mir.of_twine

let decomp_res_of_twine : Imandrax_api_tasks.Decomp_res.Shallow.t Imandrakit_twine.Decode.decoder = Imandrax_api_tasks.Decomp_res.Shallow.of_twine

let report_of_twine : Imandrax_api_report.Report.t Imandrakit_twine.Decode.decoder = Imandrax_api_report.Report.of_twine

let of_twine : type a. a kind -> a Imandrakit_twine.Decode.decoder = function
| Term -> Imandrax_api_mir.Term.of_twine
| Type -> Imandrax_api_mir.Type.of_twine
| PO_task -> Imandrax_api_tasks.PO_task.Mir.of_twine
| PO_res -> Imandrax_api_tasks.PO_res.Shallow.of_twine
| Eval_task -> Imandrax_api_tasks.Eval_task.Mir.of_twine
| Eval_res -> Imandrax_api_tasks.Eval_res.of_twine
| Model -> Imandrax_api_mir.Model.of_twine
| Show -> (fun d i -> Imandrakit_twine.Decode.(string d @@ deref_rec d i))
| Fun_decomp -> Imandrax_api_mir.Fun_decomp.of_twine
| Decomp_task -> Imandrax_api_tasks.Decomp_task.Mir.of_twine
| Decomp_res -> Imandrax_api_tasks.Decomp_res.Shallow.of_twine
| Report -> Imandrax_api_report.Report.of_twine

let pp out (Artifact {kind;data=x;storage=_}) : unit = match kind with
| Term -> Imandrax_api_mir.Term.pp out x
| Type -> Imandrax_api_mir.Type.pp out x
| PO_task -> Imandrax_api_tasks.PO_task.Mir.pp out x
| PO_res -> Imandrax_api_tasks.PO_res.Shallow.pp out x
| Eval_task -> Imandrax_api_tasks.Eval_task.Mir.pp out x
| Eval_res -> Imandrax_api_tasks.Eval_res.pp out x
| Model -> Imandrax_api_mir.Model.pp out x
| Show -> CCFormat.Dump.string out x
| Fun_decomp -> Imandrax_api_mir.Fun_decomp.pp out x
| Decomp_task -> Imandrax_api_tasks.Decomp_task.Mir.pp out x
| Decomp_res -> Imandrax_api_tasks.Decomp_res.Shallow.pp out x
| Report -> Imandrax_api_report.Report.pp out x

