let pf = Printf.printf

type kind = {
  name: string;
  ty: string;
  tag: string;
  docstring: string;
  to_twine: string;
  of_twine: string;
}

let mk ~tag ~docstring ?to_twine ?of_twine name ty : kind =
  let to_twine =
    match to_twine with
    | Some t -> t
    | None ->
      let pre = CCString.chop_suffix ~suf:".t" ty |> Option.get in
      pre ^ ".to_twine"
  in
  let of_twine =
    match of_twine with
    | Some t -> t
    | None ->
      let pre = CCString.chop_suffix ~suf:".t" ty |> Option.get in
      pre ^ ".of_twine"
  in
  { name; ty; tag; to_twine; of_twine; docstring }

let all : kind list =
  [
    mk "Term" "Cir.Term.t" ~tag:"term" ~docstring:"A CIR term";
    mk "Type" "Cir.Type.t" ~tag:"ty" ~docstring:"A CIR type";
    mk "PO_task" "Task.PO_task.t" ~tag:"po_task"
      ~docstring:"Task to verify a Proof Obligation";
    mk "PO_res" "Task.PO_res.t" ~tag:"po_res"
      ~docstring:"Result of verifying a PO";
    mk "Eval_task" "Task.Eval_task.t" ~tag:"eval_task"
      ~docstring:"Task to evaluate a term";
    mk "Eval_res" "Task.Eval_res.t" ~tag:"eval_res"
      ~docstring:"Result of evaluating a term";
    mk "Show" "string" ~tag:"show"
      ~to_twine:"(fun _enc s -> Imandrakit_twine.Immediate.string s)"
      ~of_twine:"Imandrakit_twine.Decode.string"
      ~docstring:"A human readable description";
  ]

let prelude =
  {|
(* this file is autogenerated, do not edit *)

open struct
  let spf = Printf.sprintf
end

module Cir = Imandrax_api_cir
module Task = Imandrax_api_tasks
|}

let middle =
  {|
(** An artifact. *)
type t = Artifact : 'a kind * 'a -> t

(** Pack together an artifact *)
let[@inline] make ~kind x : t = Artifact (kind, x)
|}

let () =
  pf "%s\n" prelude;

  pf "(** The kind of artifact. *)\n";
  pf "type _ kind =\n";
  List.iter
    (fun { name; ty; docstring; _ } ->
      pf "| %s : %s kind\n(** %s *)\n" name ty docstring)
    all;
  pf "\n\n";

  pf "let kind_to_string : type a. a kind -> string = function\n";
  List.iter (fun { name; tag; _ } -> pf "  | %s -> %S\n" name tag) all;
  pf "\n\n";

  pf "(** A type erased kind. *)\n";
  pf "type any_kind = Any_kind : _ kind -> any_kind\n\n";

  pf "let any_kind_to_string (Any_kind k) : string = kind_to_string k\n\n";

  pf "let kind_of_string : string -> (any_kind, string) result = function\n";
  List.iter
    (fun { name; tag; _ } -> pf "  | %S -> Ok (Any_kind %s)\n" tag name)
    all;
  pf "  | s -> Error (spf {|Unknown artifact kind: %%S|} s)\n";
  pf "\n\n";

  List.iter
    (fun { name; tag; _ } ->
      pf "let is_%s : string -> bool = fun str -> str = %S\n"
        (String.lowercase_ascii name)
        tag)
    all;

  pf "%s\n" middle;

  List.iter
    (fun { name; ty; _ } ->
      pf "let[@inline] make_%s : %s -> t = fun x -> make ~kind:%s x\n\n"
        (String.lowercase_ascii name)
        ty name;
      pf "let as_%s : t -> %s option = function\n"
        (String.lowercase_ascii name)
        ty;
      pf "  | Artifact (%s, x) -> Some x\n" name;
      pf "  | _ -> None\n\n")
    all;

  pf
    "let to_twine : t Imandrakit_twine.Encode.encoder = fun enc (Artifact \
     (tag, x)) -> match tag with\n";
  List.iter
    (fun { name; to_twine; _ } -> pf "|  %s -> %s enc x\n" name to_twine)
    all;

  List.iter
    (fun { name; ty; of_twine; _ } ->
      pf "let %s_of_twine : %s Imandrakit_twine.Decode.decoder = %s\n\n"
        (String.lowercase_ascii name)
        ty of_twine)
    all;

  pf
    "let of_twine : type a. a kind -> a Imandrakit_twine.Decode.decoder = \
     function\n";
  List.iter (fun { name; of_twine; _ } -> pf "| %s -> %s\n" name of_twine) all;

  ()
