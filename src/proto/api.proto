
syntax = "proto3";

import "utils.proto";
import "error.proto";
import "session.proto";

package imandrax.api;

// artifacts as messages
import "../lib/artifact/artmsg.proto";

enum TaskKind {
  TASK_UNSPECIFIED = 0;
  TASK_EVAL = 1;
  TASK_CHECK_PO = 2;
  TASK_PROOF_CHECK = 3;
}

message TaskID {
  // The task identifier.
  string id = 1;
}

message Task {
  TaskID id = 1;
  TaskKind kind = 2;
}

// ## Evaluation of snippets
//
// Here we evalute snippets of imandra code that do not live
// explicitly in a file. As would be the case in a REPL,
// or a notebook, they are just free-floating code snippets.

message CodeSnippet {
  Session session = 1;

  /// Code snippet.
  string code = 2;
}

enum EvalResult {
  EVAL_OK = 0;
  EVAL_ERRORS = 1;
}

message CodeSnippetEvalResult {
  // Result of the evaluation
  EvalResult res = 1;

  // TODO: defined CIR symbols

  /// Duration in seconds.
  float duration_s = 3;

  // Tasks produced in the evaluation.
  repeated Task tasks = 9;

  // Errors occurring during evaluation.
  repeated Error errors = 10;
}

message ParseQuery {
  // string to parse
  string code = 1;
}

message ArtifactListQuery {
  // the task from which to list the artifacts
  TaskID task_id = 1;
}

message ArtifactListResult {
  // the kinds of artifacts available for this task
  repeated string kinds = 1;
}

message ArtifactGetQuery {
  // the task from which the artifact comes from
  TaskID task_id = 1;

  // the kind of artifact we want
  string kind = 2;
}

message Artifact {
  // requested artifact
  Art art = 1;
}

service Eval {
  /// Evaluate a snippet
  rpc eval_code_snippet(CodeSnippet) returns (CodeSnippetEvalResult);

  // parse+typecheck a term, return it as artifact
  rpc parse_term(CodeSnippet) returns (Artifact);

  // parse+typecheck a type, return it as artifact
  rpc parse_type(CodeSnippet) returns (Artifact);

  rpc list_artifacts(ArtifactListQuery) returns (ArtifactListResult);

  // Obtain an artifact from a task
  rpc get_artifact(ArtifactGetQuery) returns (Artifact);
}
