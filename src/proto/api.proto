
syntax = "proto3";

import "utils.proto";
import "error.proto";

// artifacts as messages
import "../artifact/artmsg.proto";

enum TaskKind {
  TASK_UNSPECIFIED = 0;
  TASK_EVAL = 1;
  TASK_CHECK_PO = 2;
  TASK_PROOF_CHECK = 3;
}

message TaskID {
  // The task identifier.
  string id = 1;
}

message Task {
  TaskID id = 1;
  TaskKind kind = 2;
}

// ## Session management

// A session identifier.
message Session {
  // The session's unique ID (e.g a uuid). 
  string id = 1;
}

message SessionCreate {
  /// Do we check Proof Obligations? Default true.
  optional bool po_check = 1;
}

/// Reconnect to the given session
message SessionOpen {
  Session id = 1;
}

service SessionManager {
  // Create a new session.
  rpc create_session(SessionCreate) returns (Session);

  // Open an existing session, ie fail if it's not existing
  rpc open_session (SessionOpen) returns (Empty);

  /// Make sure the session remains active
  rpc keep_session_alive(Session) returns (Empty);
}

// ## Evaluation of snippets
//
// Here we evalute snippets of imandra code that do not live
// explicitly in a file. As would be the case in a REPL,
// or a notebook, they are just free-floating code snippets.

message CodeSnippet {
  Session session = 1;

  /// Code snippet.
  string code = 2;
}

enum EvalResult {
  EVAL_OK = 0;
  EVAL_ERRORS = 1;
}

message CodeSnippetEvalResult {
  // Result of the evaluation
  EvalResult res = 1;

  // TODO: defined CIR symbols

  /// Duration in seconds.
  float duration_s = 3;

  // Tasks produced in the evaluation.
  repeated Task tasks = 9;

  // Errors occurring during evaluation.
  repeated Error errors = 10;
}

message ParseQuery {
  // string to parse
  string code = 1;
}

message ArtifactListQuery {
  // the task from which to list the artifacts
  TaskID task_id = 1;
}

message ArtifactListResult {
  // the kinds of artifacts available for this task
  repeated string kinds = 1;
}

message ArtifactGetQuery {
  // the task from which the artifact comes from
  TaskID task_id = 1;

  // the kind of artifact we want
  string kind = 2;
}

message Artifact {
  // requested artifact
  Art art = 1;
}

service Eval {
  /// Evaluate a snippet
  rpc eval_code_snippet(CodeSnippet) returns (CodeSnippetEvalResult);

  // parse+typecheck a term, return it as artifact
  rpc parse_term(CodeSnippet) returns (Artifact);

  // parse+typecheck a type, return it as artifact
  rpc parse_type(CodeSnippet) returns (Artifact);

  rpc list_artifacts(ArtifactListQuery) returns (ArtifactListResult);

  // Obtain an artifact from a task
  rpc get_artifact(ArtifactGetQuery) returns (Artifact);
}

// ## GC statistics.
//
// This part of the API is mostly redundant given we have telemetry,
// but it's still good to have in a pinch.

message Gc_stats {
  int64 heap_size_B = 1;
  int64 major_collections = 2;
  int64 minor_collections = 3;
}

message VersionResponse {
  string version = 1;
  optional string git_version = 2;
}

/// Service returning data about the ImandraX system itself.
service System {
  /// Return the system's version
  rpc version(Empty) returns (VersionResponse);

  /// Capture GC statistics
  rpc gc_stats(Empty) returns (Gc_stats);

  /// Try to free memory, return stats
  rpc release_memory(Empty) returns (Gc_stats);
}

